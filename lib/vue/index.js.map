{"version":3,"file":"index.js","sources":["../../src/src/core/utils.ts","../../src/src/core/cache.ts","../../src/src/core/environment.ts","../../src/src/core/store.ts","../../src/src/core/resizer.ts","../../src/src/core/scroller.ts","../../src/src/vue/ListItem.tsx","../../src/src/vue/utils.ts","../../src/src/vue/Virtualizer.tsx","../../src/src/vue/VList.tsx","../../src/src/vue/WindowVirtualizer.tsx"],"sourcesContent":["/** @internal */\nexport const NULL = null;\n\n/** @internal */\nexport const min = Math.min;\n/** @internal */\nexport const max = Math.max;\n/** @internal */\nexport const abs = Math.abs;\n/** @internal */\nexport const values = Object.values;\n/** @internal */\nexport const isArray = Array.isArray;\n/** @internal */\nexport const timeout = setTimeout;\n\n/**\n * @internal\n */\nexport const clamp = (\n  value: number,\n  minValue: number,\n  maxValue: number\n): number => min(maxValue, max(minValue, value));\n\n/**\n * @internal\n */\nexport const sort = <T extends number>(arr: readonly T[]): T[] => {\n  return [...arr].sort((a, b) => a - b);\n};\n\n/**\n * @internal\n */\nexport const median = (arr: number[]): number => {\n  const sorted = sort(arr);\n  const mid = (arr.length / 2) | 0;\n  return sorted.length % 2 === 0\n    ? (sorted[mid - 1]! + sorted[mid]!) / 2\n    : sorted[mid]!;\n};\n\n/**\n * @internal\n */\nexport const microtask: (fn: () => void) => void =\n  typeof queueMicrotask === \"function\"\n    ? queueMicrotask\n    : (fn) => {\n        Promise.resolve().then(fn);\n      };\n\n/**\n * @internal\n */\nexport const debounce = <T extends () => void>(fn: T, ms: number) => {\n  let id: ReturnType<typeof setTimeout> | undefined | null;\n\n  const cancel = () => {\n    if (id != NULL) {\n      clearTimeout(id);\n    }\n  };\n  const debouncedFn = () => {\n    cancel();\n    id = timeout(() => {\n      id = NULL;\n      fn();\n    }, ms);\n  };\n  debouncedFn._cancel = cancel;\n  return debouncedFn;\n};\n\n/**\n * @internal\n */\nexport const once = <F extends (...args: any[]) => any>(fn: F): F => {\n  let called: undefined | boolean;\n  let cache: ReturnType<F>;\n\n  return ((...args) => {\n    if (!called) {\n      called = true;\n      cache = fn(...args);\n    }\n    return cache;\n  }) as F;\n};\n\n/**\n * @internal\n */\nexport const getStyleNumber = (v: string): number => {\n  if (v) {\n    return parseFloat(v);\n  } else {\n    return 0;\n  }\n};\n","import { type InternalCacheSnapshot, type ItemsRange } from \"./types\";\nimport { clamp, max, median, min } from \"./utils\";\n\ntype Writeable<T> = {\n  -readonly [key in keyof T]: Writeable<T[key]>;\n};\n\n/** @internal */\nexport const UNCACHED = -1;\n\n/**\n * @internal\n */\nexport type Cache = {\n  readonly _length: number;\n  // sizes\n  readonly _sizes: number[];\n  readonly _defaultItemSize: number;\n  // offsets\n  readonly _computedOffsetIndex: number;\n  readonly _offsets: number[];\n};\n\nconst fill = (array: number[], length: number, prepend?: boolean): number[] => {\n  const key = prepend ? \"unshift\" : \"push\";\n  for (let i = 0; i < length; i++) {\n    array[key](UNCACHED);\n  }\n  return array;\n};\n\n/**\n * @internal\n */\nexport const getItemSize = (cache: Cache, index: number): number => {\n  const size = cache._sizes[index]!;\n  return size === UNCACHED ? cache._defaultItemSize : size;\n};\n\n/**\n * @internal\n */\nexport const setItemSize = (\n  cache: Writeable<Cache>,\n  index: number,\n  size: number\n): boolean => {\n  const isInitialMeasurement = cache._sizes[index] === UNCACHED;\n  cache._sizes[index] = size;\n  // mark as dirty\n  cache._computedOffsetIndex = min(index, cache._computedOffsetIndex);\n  return isInitialMeasurement;\n};\n\n/**\n * @internal\n */\nexport const computeOffset = (\n  cache: Writeable<Cache>,\n  index: number\n): number => {\n  if (!cache._length) return 0;\n  if (cache._computedOffsetIndex >= index) {\n    return cache._offsets[index]!;\n  }\n\n  if (cache._computedOffsetIndex < 0) {\n    // first offset must be 0 to avoid returning NaN, which can cause infinite rerender.\n    // https://github.com/inokawa/virtua/pull/160\n    cache._offsets[0] = 0;\n    cache._computedOffsetIndex = 0;\n  }\n  let i = cache._computedOffsetIndex;\n  let top = cache._offsets[i]!;\n  while (i < index) {\n    top += getItemSize(cache, i);\n    cache._offsets[++i] = top;\n  }\n  // mark as measured\n  cache._computedOffsetIndex = index;\n  return top;\n};\n\n/**\n * @internal\n */\nexport const computeTotalSize = (cache: Cache): number => {\n  if (!cache._length) return 0;\n  return (\n    computeOffset(cache, cache._length - 1) +\n    getItemSize(cache, cache._length - 1)\n  );\n};\n\n/**\n * @internal\n */\nexport const findIndex = (cache: Cache, offset: number, i: number): number => {\n  while (i >= 0 && i < cache._length) {\n    const itemOffset = computeOffset(cache, i);\n    if (itemOffset <= offset) {\n      if (itemOffset + getItemSize(cache, i) > offset) {\n        break;\n      } else {\n        i++;\n      }\n    } else {\n      i--;\n    }\n  }\n  return clamp(i, 0, cache._length - 1);\n};\n\n/**\n * @internal\n */\nexport const computeRange = (\n  cache: Cache,\n  scrollOffset: number,\n  prevStartIndex: number,\n  viewportSize: number\n): ItemsRange => {\n  const start = findIndex(\n    cache,\n    scrollOffset,\n    // Clamp because prevStartIndex may exceed the limit when children decreased a lot after scrolling\n    min(prevStartIndex, cache._length - 1)\n  );\n  return [start, findIndex(cache, scrollOffset + viewportSize, start)];\n};\n\n/**\n * @internal\n */\nexport const estimateDefaultItemSize = (\n  cache: Writeable<Cache>,\n  startIndex: number\n): number => {\n  let measuredCountBeforeStart = 0;\n  // This function will be called after measurement so measured size array must be longer than 0\n  const measuredSizes = cache._sizes.filter((s, i) => {\n    const isMeasured = s !== UNCACHED;\n    if (isMeasured && i < startIndex) {\n      measuredCountBeforeStart++;\n    }\n    return isMeasured;\n  });\n  const prevDefaultItemSize = cache._defaultItemSize;\n\n  // Discard cache for now\n  cache._computedOffsetIndex = -1;\n\n  // Calculate diff of unmeasured items before start\n  return (\n    ((cache._defaultItemSize = median(measuredSizes)) - prevDefaultItemSize) *\n    max(startIndex - measuredCountBeforeStart, 0)\n  );\n};\n\n/**\n * @internal\n */\nexport const initCache = (\n  length: number,\n  itemSize: number,\n  snapshot?: InternalCacheSnapshot\n): Cache => {\n  return {\n    _defaultItemSize: snapshot ? snapshot[1] : itemSize,\n    _sizes:\n      snapshot && snapshot[0]\n        ? // https://github.com/inokawa/virtua/issues/441\n          fill(\n            snapshot[0].slice(0, min(length, snapshot[0].length)),\n            max(0, length - snapshot[0].length)\n          )\n        : fill([], length),\n    _length: length,\n    _computedOffsetIndex: -1,\n    _offsets: fill([], length),\n  };\n};\n\n/**\n * @internal\n */\nexport const takeCacheSnapshot = (cache: Cache): InternalCacheSnapshot => {\n  return [[...cache._sizes], cache._defaultItemSize];\n};\n\n/**\n * @internal\n */\nexport const updateCacheLength = (\n  cache: Writeable<Cache>,\n  length: number,\n  isShift?: boolean\n): number => {\n  const diff = length - cache._length;\n\n  cache._computedOffsetIndex = isShift\n    ? // Discard cache for now\n      -1\n    : min(length - 1, cache._computedOffsetIndex);\n  cache._length = length;\n\n  if (diff > 0) {\n    // Added\n    fill(cache._offsets, diff);\n    fill(cache._sizes, diff, isShift);\n    return cache._defaultItemSize * diff;\n  } else {\n    // Removed\n    cache._offsets.splice(diff);\n    return (\n      isShift ? cache._sizes.splice(0, -diff) : cache._sizes.splice(diff)\n    ).reduce(\n      (acc, removed) =>\n        acc - (removed === UNCACHED ? cache._defaultItemSize : removed),\n      0\n    );\n  }\n};\n","import { once } from \"./utils\";\n\n/**\n * @internal\n */\nexport const isBrowser = typeof window !== \"undefined\";\n\nconst getDocumentElement = () => document.documentElement;\n\n/**\n * @internal\n */\nexport const getCurrentDocument = (node: HTMLElement): Document =>\n  node.ownerDocument;\n\n/**\n * @internal\n */\nexport const getCurrentWindow = (doc: Document) => doc.defaultView!;\n\n/**\n * @internal\n */\nexport const isRTLDocument = /*#__PURE__*/ once((): boolean => {\n  // TODO support SSR in rtl\n  return isBrowser\n    ? getComputedStyle(getDocumentElement()).direction === \"rtl\"\n    : false;\n});\n\n/**\n * Currently, all browsers on iOS/iPadOS are WebKit, including WebView.\n * @internal\n */\nexport const isIOSWebKit = /*#__PURE__*/ once((): boolean => {\n  return /iP(hone|od|ad)/.test(navigator.userAgent);\n});\n\n/**\n * @internal\n */\nexport const isSmoothScrollSupported = /*#__PURE__*/ once((): boolean => {\n  return \"scrollBehavior\" in getDocumentElement().style;\n});\n","import {\n  initCache,\n  getItemSize as _getItemSize,\n  computeTotalSize,\n  computeOffset as computeStartOffset,\n  UNCACHED,\n  setItemSize,\n  estimateDefaultItemSize,\n  updateCacheLength,\n  computeRange,\n  takeCacheSnapshot,\n} from \"./cache\";\nimport { isIOSWebKit } from \"./environment\";\nimport type {\n  CacheSnapshot,\n  InternalCacheSnapshot,\n  ItemResize,\n  ItemsRange,\n} from \"./types\";\nimport { abs, max, min, NULL } from \"./utils\";\n\n/** @internal */\nexport const SCROLL_IDLE = 0;\n/** @internal */\nexport const SCROLL_DOWN = 1;\n/** @internal */\nexport const SCROLL_UP = 2;\n/** @internal */\nexport type ScrollDirection =\n  | typeof SCROLL_IDLE\n  | typeof SCROLL_DOWN\n  | typeof SCROLL_UP;\n\nconst SCROLL_BY_NATIVE = 0;\nconst SCROLL_BY_MANUAL_SCROLL = 1;\nconst SCROLL_BY_SHIFT = 2;\ntype ScrollMode =\n  | typeof SCROLL_BY_NATIVE\n  | typeof SCROLL_BY_MANUAL_SCROLL\n  | typeof SCROLL_BY_SHIFT;\n\n/** @internal */\nexport const ACTION_SCROLL = 1;\n/** @internal */\nexport const ACTION_SCROLL_END = 2;\n/** @internal */\nexport const ACTION_ITEM_RESIZE = 3;\n/** @internal */\nexport const ACTION_VIEWPORT_RESIZE = 4;\n/** @internal */\nexport const ACTION_ITEMS_LENGTH_CHANGE = 5;\n/** @internal */\nexport const ACTION_START_OFFSET_CHANGE = 6;\n/** @internal */\nexport const ACTION_MANUAL_SCROLL = 7;\n/** @internal */\nexport const ACTION_BEFORE_MANUAL_SMOOTH_SCROLL = 8;\n\ntype Actions =\n  | [type: typeof ACTION_SCROLL, offset: number]\n  | [type: typeof ACTION_SCROLL_END, dummy?: void]\n  | [type: typeof ACTION_ITEM_RESIZE, entries: ItemResize[]]\n  | [type: typeof ACTION_VIEWPORT_RESIZE, size: number]\n  | [\n      type: typeof ACTION_ITEMS_LENGTH_CHANGE,\n      arg: [length: number, isShift?: boolean | undefined],\n    ]\n  | [type: typeof ACTION_START_OFFSET_CHANGE, offset: number]\n  | [type: typeof ACTION_MANUAL_SCROLL, dummy?: void]\n  | [type: typeof ACTION_BEFORE_MANUAL_SMOOTH_SCROLL, offset: number];\n\n/** @internal */\nexport const UPDATE_VIRTUAL_STATE = 0b0001;\n/** @internal */\nexport const UPDATE_SIZE_EVENT = 0b0010;\n/** @internal */\nexport const UPDATE_SCROLL_EVENT = 0b0100;\n/** @internal */\nexport const UPDATE_SCROLL_END_EVENT = 0b1000;\n\n/**\n * @internal\n */\nexport const getScrollSize = (store: VirtualStore): number => {\n  return max(store._getTotalSize(), store._getViewportSize());\n};\n\n/**\n * @internal\n */\nexport const getOverscanedRange = (\n  startIndex: number,\n  endIndex: number,\n  overscan: number,\n  scrollDirection: ScrollDirection,\n  count: number\n): ItemsRange => {\n  if (scrollDirection !== SCROLL_DOWN) {\n    startIndex -= max(0, overscan);\n  }\n  if (scrollDirection !== SCROLL_UP) {\n    endIndex += max(0, overscan);\n  }\n  return [max(startIndex, 0), min(endIndex, count - 1)];\n};\n\ntype Subscriber = (sync?: boolean) => void;\n\n/** @internal */\nexport type StateVersion = readonly [];\n\n/**\n * @internal\n */\nexport type VirtualStore = {\n  _getStateVersion(): StateVersion;\n  _getCacheSnapshot(): CacheSnapshot;\n  _getRange(): ItemsRange;\n  _isUnmeasuredItem(index: number): boolean;\n  _isInitialMeasurementDone(): boolean;\n  _hasUnmeasuredItemsInFrozenRange(): boolean;\n  _getItemOffset(index: number): number;\n  _getItemSize(index: number): number;\n  _getItemsLength(): number;\n  _getScrollOffset(): number;\n  _getScrollDirection(): ScrollDirection;\n  _getViewportSize(): number;\n  _getStartSpacerSize(): number;\n  _getTotalSize(): number;\n  _getJumpCount(): number;\n  _flushJump(): [number, boolean];\n  _subscribe(target: number, cb: Subscriber): () => void;\n  _update(...action: Actions): void;\n};\n\n/**\n * @internal\n */\nexport const createVirtualStore = (\n  elementsCount: number,\n  itemSize: number = 40,\n  ssrCount: number = 0,\n  cacheSnapshot?: CacheSnapshot | undefined,\n  shouldAutoEstimateItemSize: boolean = false\n): VirtualStore => {\n  let isSSR = !!ssrCount;\n  let stateVersion: StateVersion = [];\n  let viewportSize = 0;\n  let startSpacerSize = 0;\n  let scrollOffset = 0;\n  let jumpCount = 0;\n  let jump = 0;\n  let pendingJump = 0;\n  let _flushedJump = 0;\n  let _scrollDirection: ScrollDirection = SCROLL_IDLE;\n  let _scrollMode: ScrollMode = SCROLL_BY_NATIVE;\n  let _frozenRange: ItemsRange | null = isSSR\n    ? [0, max(ssrCount - 1, 0)]\n    : NULL;\n  let _prevRange: ItemsRange = [0, 0];\n  let _totalMeasuredSize = 0;\n\n  const cache = initCache(\n    elementsCount,\n    itemSize,\n    cacheSnapshot as unknown as InternalCacheSnapshot | undefined\n  );\n  const subscribers = new Set<[number, Subscriber]>();\n  const getRelativeScrollOffset = () => scrollOffset - startSpacerSize;\n  const getRange = (offset: number) => {\n    return computeRange(cache, offset, _prevRange[0], viewportSize);\n  };\n  const getTotalSize = (): number => computeTotalSize(cache);\n  const getItemOffset = (index: number): number => {\n    return computeStartOffset(cache, index) - pendingJump;\n  };\n  const getItemSize = (index: number): number => {\n    return _getItemSize(cache, index);\n  };\n\n  const applyJump = (j: number) => {\n    if (j) {\n      // In iOS WebKit browsers, updating scroll position will stop scrolling so it have to be deferred during scrolling.\n      if (isIOSWebKit() && _scrollDirection !== SCROLL_IDLE) {\n        pendingJump += j;\n      } else {\n        jump += j;\n        jumpCount++;\n      }\n    }\n  };\n\n  return {\n    _getStateVersion() {\n      return stateVersion;\n    },\n    _getCacheSnapshot() {\n      return takeCacheSnapshot(cache) as unknown as CacheSnapshot;\n    },\n    _getRange() {\n      // Return previous range for consistent render until next scroll event comes in.\n      if (_flushedJump) {\n        return _prevRange;\n      }\n      _prevRange = getRange(\n        max(0, getRelativeScrollOffset() + pendingJump + jump)\n      );\n\n      if (_frozenRange) {\n        return [\n          min(_prevRange[0], _frozenRange[0]),\n          max(_prevRange[1], _frozenRange[1]),\n        ];\n      }\n      return _prevRange;\n    },\n    _isUnmeasuredItem(index) {\n      return cache._sizes[index] === UNCACHED;\n    },\n    _isInitialMeasurementDone() {\n      return !!viewportSize;\n    },\n    _hasUnmeasuredItemsInFrozenRange() {\n      if (!_frozenRange) return false;\n      return cache._sizes\n        .slice(\n          max(0, _frozenRange[0] - 1),\n          min(cache._length - 1, _frozenRange[1] + 1) + 1\n        )\n        .includes(UNCACHED);\n    },\n    _getItemOffset: getItemOffset,\n    _getItemSize: getItemSize,\n    _getItemsLength() {\n      return cache._length;\n    },\n    _getScrollOffset() {\n      return scrollOffset;\n    },\n    _getScrollDirection() {\n      return _scrollDirection;\n    },\n    _getViewportSize() {\n      return viewportSize;\n    },\n    _getStartSpacerSize() {\n      return startSpacerSize;\n    },\n    _getTotalSize: getTotalSize,\n    _getJumpCount() {\n      return jumpCount;\n    },\n    _flushJump() {\n      _flushedJump = jump;\n      jump = 0;\n      return [\n        _flushedJump,\n        // Use absolute position not to exceed scrollable bounds\n        _scrollMode === SCROLL_BY_SHIFT ||\n          // https://github.com/inokawa/virtua/discussions/475\n          getRelativeScrollOffset() + viewportSize >= getTotalSize(),\n      ];\n    },\n    _subscribe(target, cb) {\n      const sub: [number, Subscriber] = [target, cb];\n      subscribers.add(sub);\n      return () => {\n        subscribers.delete(sub);\n      };\n    },\n    _update(type, payload): void {\n      let shouldFlushPendingJump: boolean | undefined;\n      let shouldSync: boolean | undefined;\n      let mutated = 0;\n\n      switch (type) {\n        case ACTION_SCROLL: {\n          const flushedJump = _flushedJump;\n          _flushedJump = 0;\n\n          const delta = payload - scrollOffset;\n          const distance = abs(delta);\n\n          // Scroll event after jump compensation is not reliable because it may result in the opposite direction.\n          // The delta of artificial scroll may not be equal with the jump because it may be batched with other scrolls.\n          // And at least in latest Chrome/Firefox/Safari in 2023, setting value to scrollTop/scrollLeft can lose subpixel because its integer (sometimes float probably depending on dpr).\n          const isJustJumped = flushedJump && distance < abs(flushedJump) + 1;\n\n          // Scroll events are dispatched enough so it's ok to skip some of them.\n          if (\n            !isJustJumped &&\n            // Ignore until manual scrolling\n            _scrollMode === SCROLL_BY_NATIVE\n          ) {\n            _scrollDirection = delta < 0 ? SCROLL_UP : SCROLL_DOWN;\n          }\n\n          // TODO This will cause glitch in reverse infinite scrolling. Disable this until better solution is found.\n          // if (\n          //   pendingJump &&\n          //   ((_scrollDirection === SCROLL_UP &&\n          //     payload - max(pendingJump, 0) <= 0) ||\n          //     (_scrollDirection === SCROLL_DOWN &&\n          //       payload - min(pendingJump, 0) >= getScrollOffsetMax()))\n          // ) {\n          //   // Flush if almost reached to start or end\n          //   shouldFlushPendingJump = true;\n          // }\n\n          if (isSSR) {\n            _frozenRange = NULL;\n            isSSR = false;\n          }\n\n          scrollOffset = payload;\n          mutated = UPDATE_SCROLL_EVENT;\n\n          // Skip if offset is not changed\n          // Scroll offset may exceed min or max especially in Safari's elastic scrolling.\n          const relativeOffset = getRelativeScrollOffset();\n          if (\n            relativeOffset >= -viewportSize &&\n            relativeOffset <= getTotalSize()\n          ) {\n            mutated += UPDATE_VIRTUAL_STATE;\n\n            // Update synchronously if scrolled a lot\n            shouldSync = distance > viewportSize;\n          }\n          break;\n        }\n        case ACTION_SCROLL_END: {\n          mutated = UPDATE_SCROLL_END_EVENT;\n          if (_scrollDirection !== SCROLL_IDLE) {\n            shouldFlushPendingJump = true;\n            mutated += UPDATE_VIRTUAL_STATE;\n          }\n          _scrollDirection = SCROLL_IDLE;\n          _scrollMode = SCROLL_BY_NATIVE;\n          _frozenRange = NULL;\n          break;\n        }\n        case ACTION_ITEM_RESIZE: {\n          const updated = payload.filter(\n            ([index, size]) => cache._sizes[index] !== size\n          );\n\n          // Skip if all items are cached and not updated\n          if (!updated.length) {\n            break;\n          }\n\n          // Calculate jump by resize to minimize junks in appearance\n          applyJump(\n            updated.reduce((acc, [index, size]) => {\n              if (\n                // Keep distance from end during shifting\n                _scrollMode === SCROLL_BY_SHIFT ||\n                (_frozenRange\n                  ? // https://github.com/inokawa/virtua/issues/380\n                    index < _frozenRange[0]\n                  : // Otherwise we should maintain visible position\n                    getItemOffset(index) +\n                      // https://github.com/inokawa/virtua/issues/385\n                      (_scrollDirection === SCROLL_IDLE &&\n                      _scrollMode === SCROLL_BY_NATIVE\n                        ? getItemSize(index)\n                        : 0) <\n                    getRelativeScrollOffset())\n              ) {\n                acc += size - getItemSize(index);\n              }\n              return acc;\n            }, 0)\n          );\n\n          // Update item sizes\n          for (const [index, size] of updated) {\n            const prevSize = getItemSize(index);\n            const isInitialMeasurement = setItemSize(cache, index, size);\n\n            if (shouldAutoEstimateItemSize) {\n              _totalMeasuredSize += isInitialMeasurement\n                ? size\n                : size - prevSize;\n            }\n          }\n\n          // Estimate initial item size from measured sizes\n          if (\n            shouldAutoEstimateItemSize &&\n            viewportSize &&\n            // If the total size is lower than the viewport, the item may be a empty state\n            _totalMeasuredSize > viewportSize\n          ) {\n            applyJump(estimateDefaultItemSize(cache, _prevRange[0]));\n            shouldAutoEstimateItemSize = false;\n          }\n\n          mutated = UPDATE_VIRTUAL_STATE + UPDATE_SIZE_EVENT;\n\n          // Synchronous update is necessary in current design to minimize visible glitch in concurrent rendering.\n          // However in React, synchronous update with flushSync after asynchronous update will overtake the asynchronous one.\n          // If items resize happens just after scroll, race condition can occur depending on implementation.\n          shouldSync = true;\n          break;\n        }\n        case ACTION_VIEWPORT_RESIZE: {\n          if (viewportSize !== payload) {\n            viewportSize = payload;\n            mutated = UPDATE_VIRTUAL_STATE + UPDATE_SIZE_EVENT;\n          }\n          break;\n        }\n        case ACTION_ITEMS_LENGTH_CHANGE: {\n          if (payload[1]) {\n            applyJump(updateCacheLength(cache, payload[0], true));\n            _scrollMode = SCROLL_BY_SHIFT;\n            mutated = UPDATE_VIRTUAL_STATE;\n          } else {\n            updateCacheLength(cache, payload[0]);\n          }\n          break;\n        }\n        case ACTION_START_OFFSET_CHANGE: {\n          startSpacerSize = payload;\n          break;\n        }\n        case ACTION_MANUAL_SCROLL: {\n          _scrollMode = SCROLL_BY_MANUAL_SCROLL;\n          break;\n        }\n        case ACTION_BEFORE_MANUAL_SMOOTH_SCROLL: {\n          _frozenRange = getRange(payload);\n          mutated = UPDATE_VIRTUAL_STATE;\n          break;\n        }\n      }\n\n      if (mutated) {\n        stateVersion = [];\n\n        if (shouldFlushPendingJump && pendingJump) {\n          jump += pendingJump;\n          pendingJump = 0;\n          jumpCount++;\n        }\n\n        subscribers.forEach(([target, cb]) => {\n          // Early return to skip React's computation\n          if (!(mutated & target)) {\n            return;\n          }\n          // https://github.com/facebook/react/issues/25191\n          // https://github.com/facebook/react/blob/a5fc797db14c6e05d4d5c4dbb22a0dd70d41f5d5/packages/react-reconciler/src/ReactFiberWorkLoop.js#L1443-L1447\n          cb(shouldSync);\n        });\n      }\n    },\n  };\n};\n","import { getCurrentDocument, getCurrentWindow } from \"./environment\";\nimport {\n  ACTION_ITEM_RESIZE,\n  ACTION_VIEWPORT_RESIZE,\n  type VirtualStore,\n} from \"./store\";\nimport { type ItemResize } from \"./types\";\nimport { max, NULL } from \"./utils\";\n\nconst createResizeObserver = (cb: ResizeObserverCallback) => {\n  let ro: ResizeObserver | undefined;\n\n  return {\n    _observe(e: HTMLElement) {\n      // Initialize ResizeObserver lazily for SSR\n      // https://www.w3.org/TR/resize-observer/#intro\n      (\n        ro ||\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1491739\n        (ro = new (getCurrentWindow(getCurrentDocument(e)).ResizeObserver)(cb))\n      ).observe(e);\n    },\n    _unobserve(e: HTMLElement) {\n      ro!.unobserve(e);\n    },\n    _dispose() {\n      ro && ro.disconnect();\n    },\n  };\n};\n\n/**\n * @internal\n */\nexport type ItemResizeObserver = (el: HTMLElement, i: number) => () => void;\n\ninterface ListResizer {\n  _observeRoot(viewportElement: HTMLElement): void;\n  _observeItem: ItemResizeObserver;\n  _dispose(): void;\n}\n\n/**\n * @internal\n */\nexport const createResizer = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): ListResizer => {\n  let viewportElement: HTMLElement | undefined;\n  const sizeKey = isHorizontal ? \"width\" : \"height\";\n  const mountedIndexes = new WeakMap<Element, number>();\n\n  const resizeObserver = createResizeObserver((entries) => {\n    const resizes: ItemResize[] = [];\n    for (const { target, contentRect } of entries) {\n      // Skip zero-sized rects that may be observed under `display: none` style\n      if (!(target as HTMLElement).offsetParent) continue;\n\n      if (target === viewportElement) {\n        store._update(ACTION_VIEWPORT_RESIZE, contentRect[sizeKey]);\n      } else {\n        const index = mountedIndexes.get(target);\n        if (index != NULL) {\n          resizes.push([index, contentRect[sizeKey]]);\n        }\n      }\n    }\n\n    if (resizes.length) {\n      store._update(ACTION_ITEM_RESIZE, resizes);\n    }\n  });\n\n  return {\n    _observeRoot(viewport: HTMLElement) {\n      resizeObserver._observe((viewportElement = viewport));\n    },\n    _observeItem: (el: HTMLElement, i: number) => {\n      mountedIndexes.set(el, i);\n      resizeObserver._observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        resizeObserver._unobserve(el);\n      };\n    },\n    _dispose: resizeObserver._dispose,\n  };\n};\n\ninterface WindowListResizer {\n  _observeRoot(container: HTMLElement): void;\n  _observeItem: ItemResizeObserver;\n  _dispose(): void;\n}\n\n/**\n * @internal\n */\nexport const createWindowResizer = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): WindowListResizer => {\n  const sizeKey = isHorizontal ? \"width\" : \"height\";\n  const windowSizeKey = isHorizontal ? \"innerWidth\" : \"innerHeight\";\n  const mountedIndexes = new WeakMap<Element, number>();\n\n  const resizeObserver = createResizeObserver((entries) => {\n    const resizes: ItemResize[] = [];\n    for (const { target, contentRect } of entries) {\n      // Skip zero-sized rects that may be observed under `display: none` style\n      if (!(target as HTMLElement).offsetParent) continue;\n\n      const index = mountedIndexes.get(target);\n      if (index != NULL) {\n        resizes.push([index, contentRect[sizeKey]]);\n      }\n    }\n\n    if (resizes.length) {\n      store._update(ACTION_ITEM_RESIZE, resizes);\n    }\n  });\n\n  let cleanupOnWindowResize: (() => void) | undefined;\n\n  return {\n    _observeRoot(container) {\n      const window = getCurrentWindow(getCurrentDocument(container));\n      const onWindowResize = () => {\n        store._update(ACTION_VIEWPORT_RESIZE, window[windowSizeKey]);\n      };\n      window.addEventListener(\"resize\", onWindowResize);\n      onWindowResize();\n\n      cleanupOnWindowResize = () => {\n        window.removeEventListener(\"resize\", onWindowResize);\n      };\n    },\n    _observeItem: (el: HTMLElement, i: number) => {\n      mountedIndexes.set(el, i);\n      resizeObserver._observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        resizeObserver._unobserve(el);\n      };\n    },\n    _dispose() {\n      cleanupOnWindowResize && cleanupOnWindowResize();\n      resizeObserver._dispose();\n    },\n  };\n};\n\n/**\n * @internal\n */\nexport const createGridResizer = (\n  vStore: VirtualStore,\n  hStore: VirtualStore\n) => {\n  let viewportElement: HTMLElement | undefined;\n\n  const heightKey = \"height\";\n  const widthKey = \"width\";\n  const mountedIndexes = new WeakMap<\n    Element,\n    [rowIndex: number, colIndex: number]\n  >();\n\n  type CellSize = [height: number, width: number];\n  const maybeCachedRowIndexes = new Set<number>();\n  const maybeCachedColIndexes = new Set<number>();\n  const sizeCache = new Map<string, CellSize>();\n  const getKey = (rowIndex: number, colIndex: number): string =>\n    `${rowIndex}-${colIndex}`;\n\n  const resizeObserver = createResizeObserver((entries) => {\n    const resizedRows = new Set<number>();\n    const resizedCols = new Set<number>();\n    for (const { target, contentRect } of entries) {\n      // Skip zero-sized rects that may be observed under `display: none` style\n      if (!(target as HTMLElement).offsetParent) continue;\n\n      if (target === viewportElement) {\n        vStore._update(ACTION_VIEWPORT_RESIZE, contentRect[heightKey]);\n        hStore._update(ACTION_VIEWPORT_RESIZE, contentRect[widthKey]);\n      } else {\n        const cell = mountedIndexes.get(target);\n        if (cell) {\n          const [rowIndex, colIndex] = cell;\n          const key = getKey(rowIndex, colIndex);\n          const prevSize = sizeCache.get(key);\n          const size: CellSize = [\n            contentRect[heightKey],\n            contentRect[widthKey],\n          ];\n          let rowResized: boolean | undefined;\n          let colResized: boolean | undefined;\n          if (!prevSize) {\n            rowResized = colResized = true;\n          } else {\n            if (prevSize[0] !== size[0]) {\n              rowResized = true;\n            }\n            if (prevSize[1] !== size[1]) {\n              colResized = true;\n            }\n          }\n          if (rowResized) {\n            resizedRows.add(rowIndex);\n          }\n          if (colResized) {\n            resizedCols.add(colIndex);\n          }\n          if (rowResized || colResized) {\n            sizeCache.set(key, size);\n          }\n        }\n      }\n    }\n\n    if (resizedRows.size) {\n      const heightResizes: ItemResize[] = [];\n      resizedRows.forEach((rowIndex) => {\n        let maxHeight = 0;\n        maybeCachedColIndexes.forEach((colIndex) => {\n          const size = sizeCache.get(getKey(rowIndex, colIndex));\n          if (size) {\n            maxHeight = max(maxHeight, size[0]);\n          }\n        });\n        if (maxHeight) {\n          heightResizes.push([rowIndex, maxHeight]);\n        }\n      });\n      vStore._update(ACTION_ITEM_RESIZE, heightResizes);\n    }\n    if (resizedCols.size) {\n      const widthResizes: ItemResize[] = [];\n      resizedCols.forEach((colIndex) => {\n        let maxWidth = 0;\n        maybeCachedRowIndexes.forEach((rowIndex) => {\n          const size = sizeCache.get(getKey(rowIndex, colIndex));\n          if (size) {\n            maxWidth = max(maxWidth, size[1]);\n          }\n        });\n        if (maxWidth) {\n          widthResizes.push([colIndex, maxWidth]);\n        }\n      });\n      hStore._update(ACTION_ITEM_RESIZE, widthResizes);\n    }\n  });\n\n  return {\n    _observeRoot(viewport: HTMLElement) {\n      resizeObserver._observe((viewportElement = viewport));\n    },\n    _observeItem(el: HTMLElement, rowIndex: number, colIndex: number) {\n      mountedIndexes.set(el, [rowIndex, colIndex]);\n      maybeCachedRowIndexes.add(rowIndex);\n      maybeCachedColIndexes.add(colIndex);\n      resizeObserver._observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        resizeObserver._unobserve(el);\n      };\n    },\n    _dispose: resizeObserver._dispose,\n  };\n};\n\n/**\n * @internal\n */\nexport type GridResizer = ReturnType<typeof createGridResizer>;\n","import {\n  getCurrentDocument,\n  getCurrentWindow,\n  isIOSWebKit,\n  isRTLDocument,\n  isSmoothScrollSupported,\n} from \"./environment\";\nimport {\n  ACTION_SCROLL,\n  type VirtualStore,\n  ACTION_SCROLL_END,\n  UPDATE_SIZE_EVENT,\n  ACTION_MANUAL_SCROLL,\n  SCROLL_IDLE,\n  ACTION_BEFORE_MANUAL_SMOOTH_SCROLL,\n  ACTION_START_OFFSET_CHANGE,\n} from \"./store\";\nimport { type ScrollToIndexOpts } from \"./types\";\nimport { debounce, timeout, clamp, microtask } from \"./utils\";\n\n/**\n * scrollLeft is negative value in rtl direction.\n *\n * left  right\n * 0     100    spec compliant (ltr)\n * -100  0      spec compliant (rtl)\n * https://github.com/othree/jquery.rtl-scroll-type\n */\nconst normalizeOffset = (offset: number, isHorizontal: boolean): number => {\n  if (isHorizontal && isRTLDocument()) {\n    return -offset;\n  } else {\n    return offset;\n  }\n};\n\nconst createScrollObserver = (\n  store: VirtualStore,\n  viewport: HTMLElement | Window,\n  isHorizontal: boolean,\n  getScrollOffset: () => number,\n  updateScrollOffset: (\n    value: number,\n    shift: boolean,\n    isMomentumScrolling: boolean\n  ) => void,\n  getStartOffset?: () => number\n) => {\n  const now = Date.now;\n\n  let lastScrollTime = 0;\n  let wheeling = false;\n  let touching = false;\n  let justTouchEnded = false;\n  let stillMomentumScrolling = false;\n\n  const onScrollEnd = debounce(() => {\n    if (wheeling || touching) {\n      wheeling = false;\n\n      // Wait while wheeling or touching\n      onScrollEnd();\n      return;\n    }\n\n    justTouchEnded = false;\n\n    store._update(ACTION_SCROLL_END);\n  }, 150);\n\n  const onScroll = () => {\n    lastScrollTime = now();\n\n    if (justTouchEnded) {\n      stillMomentumScrolling = true;\n    }\n\n    if (getStartOffset) {\n      store._update(ACTION_START_OFFSET_CHANGE, getStartOffset());\n    }\n    store._update(ACTION_SCROLL, getScrollOffset());\n\n    onScrollEnd();\n  };\n\n  // Infer scroll state also from wheel events\n  // Sometimes scroll events do not fire when frame dropped even if the visual have been already scrolled\n  const onWheel = ((e: WheelEvent) => {\n    if (\n      wheeling ||\n      // Scroll start should be detected with scroll event\n      store._getScrollDirection() === SCROLL_IDLE ||\n      // Probably a pinch-to-zoom gesture\n      e.ctrlKey\n    ) {\n      return;\n    }\n\n    const timeDelta = now() - lastScrollTime;\n    if (\n      // Check if wheel event occurs some time after scrolling\n      150 > timeDelta &&\n      50 < timeDelta &&\n      // Get delta before checking deltaMode for firefox behavior\n      // https://github.com/w3c/uievents/issues/181#issuecomment-392648065\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1392460#c34\n      (isHorizontal ? e.deltaX : e.deltaY)\n    ) {\n      wheeling = true;\n    }\n  }) as (e: Event) => void; // FIXME type error. why only here?\n\n  const onTouchStart = () => {\n    touching = true;\n    justTouchEnded = stillMomentumScrolling = false;\n  };\n  const onTouchEnd = () => {\n    touching = false;\n    if (isIOSWebKit()) {\n      justTouchEnded = true;\n    }\n  };\n\n  viewport.addEventListener(\"scroll\", onScroll);\n  viewport.addEventListener(\"wheel\", onWheel, { passive: true });\n  viewport.addEventListener(\"touchstart\", onTouchStart, { passive: true });\n  viewport.addEventListener(\"touchend\", onTouchEnd, { passive: true });\n\n  return {\n    _dispose: () => {\n      viewport.removeEventListener(\"scroll\", onScroll);\n      viewport.removeEventListener(\"wheel\", onWheel);\n      viewport.removeEventListener(\"touchstart\", onTouchStart);\n      viewport.removeEventListener(\"touchend\", onTouchEnd);\n      onScrollEnd._cancel();\n    },\n    _fixScrollJump: () => {\n      const [jump, shift] = store._flushJump();\n      if (!jump) return;\n      updateScrollOffset(\n        normalizeOffset(jump, isHorizontal),\n        shift,\n        stillMomentumScrolling\n      );\n      stillMomentumScrolling = false;\n\n      if (shift && store._getViewportSize() > store._getTotalSize()) {\n        // In this case applying jump may not cause scroll.\n        // Current logic expects scroll event occurs after applying jump so we dispatch it manually.\n        store._update(ACTION_SCROLL, getScrollOffset());\n      }\n    },\n  };\n};\n\ntype ScrollObserver = ReturnType<typeof createScrollObserver>;\n\n/**\n * @internal\n */\nexport type Scroller = {\n  _observe: (viewportElement: HTMLElement) => void;\n  _dispose(): void;\n  _scrollTo: (offset: number) => void;\n  _scrollBy: (offset: number) => void;\n  _scrollToIndex: (index: number, opts?: ScrollToIndexOpts) => void;\n  _fixScrollJump: () => void;\n};\n\n/**\n * @internal\n */\nexport const createScroller = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): Scroller => {\n  let viewportElement: HTMLElement | undefined;\n  let scrollObserver: ScrollObserver | undefined;\n  let cancelScroll: (() => void) | undefined;\n  const scrollOffsetKey = isHorizontal ? \"scrollLeft\" : \"scrollTop\";\n  const overflowKey = isHorizontal ? \"overflowX\" : \"overflowY\";\n\n  // The given offset will be clamped by browser\n  // https://drafts.csswg.org/cssom-view/#dom-element-scrolltop\n  const scheduleImperativeScroll = async (\n    getTargetOffset: () => number,\n    smooth?: boolean\n  ) => {\n    if (!viewportElement) {\n      // Wait for element assign. The element may be undefined if scrollRef prop is used and scroll is scheduled on mount.\n      microtask(() => scheduleImperativeScroll(getTargetOffset, smooth));\n      return;\n    }\n\n    if (cancelScroll) {\n      // Cancel waiting scrollTo\n      cancelScroll();\n    }\n\n    const waitForMeasurement = (): [Promise<void>, () => void] => {\n      // Wait for the scroll destination items to be measured.\n      // The measurement will be done asynchronously and the timing is not predictable so we use promise.\n      let queue: (() => void) | undefined;\n      return [\n        new Promise<void>((resolve, reject) => {\n          queue = resolve;\n          cancelScroll = reject;\n\n          // Resize event may not happen when the window/tab is not visible, or during browser back in Safari.\n          // We have to wait for the initial measurement to avoid failing imperative scroll on mount.\n          // https://github.com/inokawa/virtua/issues/450\n          if (store._isInitialMeasurementDone()) {\n            // Reject when items around scroll destination completely measured\n            timeout(reject, 150);\n          }\n        }),\n        store._subscribe(UPDATE_SIZE_EVENT, () => {\n          queue && queue();\n        }),\n      ];\n    };\n\n    if (smooth && isSmoothScrollSupported()) {\n      while (true) {\n        store._update(ACTION_BEFORE_MANUAL_SMOOTH_SCROLL, getTargetOffset());\n\n        if (!store._hasUnmeasuredItemsInFrozenRange()) {\n          break;\n        }\n\n        const [promise, unsubscribe] = waitForMeasurement();\n\n        try {\n          await promise;\n        } catch (e) {\n          // canceled\n          return;\n        } finally {\n          unsubscribe();\n        }\n      }\n\n      viewportElement.scrollTo({\n        [isHorizontal ? \"left\" : \"top\"]: normalizeOffset(\n          getTargetOffset(),\n          isHorizontal\n        ),\n        behavior: \"smooth\",\n      });\n    } else {\n      while (true) {\n        const [promise, unsubscribe] = waitForMeasurement();\n\n        try {\n          viewportElement[scrollOffsetKey] = normalizeOffset(\n            getTargetOffset(),\n            isHorizontal\n          );\n          store._update(ACTION_MANUAL_SCROLL);\n\n          await promise;\n        } catch (e) {\n          // canceled or finished\n          return;\n        } finally {\n          unsubscribe();\n        }\n      }\n    }\n  };\n\n  return {\n    _observe(viewport) {\n      viewportElement = viewport;\n\n      scrollObserver = createScrollObserver(\n        store,\n        viewport,\n        isHorizontal,\n        () => normalizeOffset(viewport[scrollOffsetKey], isHorizontal),\n        (jump, shift, isMomentumScrolling) => {\n          // If we update scroll position while touching on iOS, the position will be reverted.\n          // However iOS WebKit fires touch events only once at the beginning of momentum scrolling.\n          // That means we have no reliable way to confirm still touched or not if user touches more than once during momentum scrolling...\n          // This is a hack for the suspectable situations, inspired by https://github.com/prud/ios-overflow-scroll-to-top\n          if (isMomentumScrolling) {\n            const style = viewport.style;\n            const prev = style[overflowKey];\n            style[overflowKey] = \"hidden\";\n            timeout(() => {\n              style[overflowKey] = prev;\n            });\n          }\n\n          if (shift) {\n            viewport[scrollOffsetKey] = store._getScrollOffset() + jump;\n            // https://github.com/inokawa/virtua/issues/357\n            cancelScroll && cancelScroll();\n          } else {\n            viewport[scrollOffsetKey] += jump;\n          }\n        }\n      );\n    },\n    _dispose() {\n      scrollObserver && scrollObserver._dispose();\n    },\n    _scrollTo(offset) {\n      scheduleImperativeScroll(() => offset);\n    },\n    _scrollBy(offset) {\n      offset += store._getScrollOffset();\n      scheduleImperativeScroll(() => offset);\n    },\n    _scrollToIndex(index, { align, smooth, offset = 0 } = {}) {\n      index = clamp(index, 0, store._getItemsLength() - 1);\n\n      if (align === \"nearest\") {\n        const itemOffset = store._getItemOffset(index);\n        const scrollOffset = store._getScrollOffset();\n\n        if (itemOffset < scrollOffset) {\n          align = \"start\";\n        } else if (\n          itemOffset + store._getItemSize(index) >\n          scrollOffset + store._getViewportSize()\n        ) {\n          align = \"end\";\n        } else {\n          // already completely visible\n          return;\n        }\n      }\n\n      scheduleImperativeScroll(() => {\n        return (\n          offset +\n          store._getStartSpacerSize() +\n          store._getItemOffset(index) +\n          (align === \"end\"\n            ? store._getItemSize(index) - store._getViewportSize()\n            : align === \"center\"\n              ? (store._getItemSize(index) - store._getViewportSize()) / 2\n              : 0)\n        );\n      }, smooth);\n    },\n    _fixScrollJump: () => {\n      scrollObserver && scrollObserver._fixScrollJump();\n    },\n  };\n};\n\n/**\n * @internal\n */\nexport type WindowScroller = {\n  _observe(containerElement: HTMLElement): void;\n  _dispose(): void;\n  _fixScrollJump: () => void;\n  _scrollToIndex: (index: number, opts?: ScrollToIndexOpts) => void;\n};\n\n/**\n * @internal\n */\nexport const createWindowScroller = (\n  store: VirtualStore,\n  isHorizontal: boolean\n): WindowScroller => {\n  let scrollObserver: ScrollObserver | undefined;\n\n  return {\n    _observe(container) {\n      const scrollOffsetKey = isHorizontal ? \"scrollX\" : \"scrollY\";\n\n      const document = getCurrentDocument(container);\n      const window = getCurrentWindow(document);\n      const documentBody = document.body;\n\n      const calcOffsetToViewport = (\n        node: HTMLElement,\n        viewport: HTMLElement,\n        isHorizontal: boolean,\n        offset: number = 0\n      ): number => {\n        // TODO calc offset only when it changes (maybe impossible)\n        const offsetKey = isHorizontal ? \"offsetLeft\" : \"offsetTop\";\n        const offsetSum =\n          offset +\n          (isHorizontal && isRTLDocument()\n            ? window.innerWidth - node[offsetKey] - node.offsetWidth\n            : node[offsetKey]);\n\n        const parent = node.offsetParent;\n        if (node === viewport || !parent) {\n          return offsetSum;\n        }\n\n        return calcOffsetToViewport(\n          parent as HTMLElement,\n          viewport,\n          isHorizontal,\n          offsetSum\n        );\n      };\n\n      scrollObserver = createScrollObserver(\n        store,\n        window,\n        isHorizontal,\n        () => normalizeOffset(window[scrollOffsetKey], isHorizontal),\n        (jump, shift) => {\n          // TODO support case two window scrollers exist in the same view\n          if (shift) {\n            window.scroll({\n              [isHorizontal ? \"left\" : \"top\"]: store._getScrollOffset() + jump,\n            });\n          } else {\n            window.scrollBy(isHorizontal ? jump : 0, isHorizontal ? 0 : jump);\n          }\n        },\n        () => calcOffsetToViewport(container, documentBody, isHorizontal)\n      );\n    },\n    _dispose() {\n      scrollObserver && scrollObserver._dispose();\n    },\n    _fixScrollJump: () => {\n      scrollObserver && scrollObserver._fixScrollJump();\n    },\n    _scrollToIndex: async (index: number, opts: ScrollToIndexOpts = {}) => {\n      // const scrollOffsetKey = isHorizontal ? \"scrollX\" : \"scrollY\";\n      const align = opts.align || \"start\";\n      const smooth = opts.smooth;\n      const offset = opts.offset || 0;\n\n      index = clamp(index, 0, store._getItemsLength() - 1);\n\n      const itemOffset = store._getItemOffset(index);\n      const viewportSize = store._getViewportSize();\n      const itemSize = store._getItemSize(index);\n\n      let targetOffset = itemOffset + offset;\n\n      if (align === \"end\") {\n        targetOffset += itemSize - viewportSize;\n      } else if (align === \"center\") {\n        targetOffset += (itemSize - viewportSize) / 2;\n      } else if (align === \"nearest\") {\n        const scrollOffset = store._getScrollOffset();\n        if (itemOffset < scrollOffset) {\n          targetOffset = itemOffset + offset;\n        } else if (itemOffset + itemSize > scrollOffset + viewportSize) {\n          targetOffset = itemOffset + itemSize - viewportSize + offset;\n        } else {\n          // already completely visible\n          return;\n        }\n      }\n\n      store._update(ACTION_BEFORE_MANUAL_SMOOTH_SCROLL, targetOffset);\n\n      const finalOffset = normalizeOffset(targetOffset, isHorizontal);\n      if (smooth && isSmoothScrollSupported()) {\n        window.scrollTo({\n          [isHorizontal ? \"left\" : \"top\"]: finalOffset,\n          behavior: \"smooth\",\n        });\n      } else {\n        window.scrollTo({\n          [isHorizontal ? \"left\" : \"top\"]: finalOffset,\n        });\n      }\n\n      await new Promise((resolve) => {\n        window.requestAnimationFrame(resolve);\n      });\n\n      store._update(ACTION_MANUAL_SCROLL);\n    },\n  };\n};\n\n/**\n * @internal\n */\nexport type GridScroller = {\n  _observe: (viewportElement: HTMLElement) => void;\n  _dispose(): void;\n  _scrollTo: (offsetX: number, offsetY: number) => void;\n  _scrollBy: (offsetX: number, offsetY: number) => void;\n  _scrollToIndex: (indexX: number, indexY: number) => void;\n  _fixScrollJump: () => void;\n};\n\n/**\n * @internal\n */\nexport const createGridScroller = (\n  vStore: VirtualStore,\n  hStore: VirtualStore\n): GridScroller => {\n  const vScroller = createScroller(vStore, false);\n  const hScroller = createScroller(hStore, true);\n  return {\n    _observe(viewportElement) {\n      vScroller._observe(viewportElement);\n      hScroller._observe(viewportElement);\n    },\n    _dispose() {\n      vScroller._dispose();\n      hScroller._dispose();\n    },\n    _scrollTo(offsetX, offsetY) {\n      vScroller._scrollTo(offsetY);\n      hScroller._scrollTo(offsetX);\n    },\n    _scrollBy(offsetX, offsetY) {\n      vScroller._scrollBy(offsetY);\n      hScroller._scrollBy(offsetX);\n    },\n    _scrollToIndex(indexX, indexY) {\n      vScroller._scrollToIndex(indexY);\n      hScroller._scrollToIndex(indexX);\n    },\n    _fixScrollJump() {\n      vScroller._fixScrollJump();\n      hScroller._fixScrollJump();\n    },\n  };\n};\n","/** @jsxImportSource vue */\nimport {\n  ref,\n  defineComponent,\n  watch,\n  StyleValue,\n  PropType,\n  VNode,\n  NativeElements,\n} from \"vue\";\nimport { ItemResizeObserver } from \"../core/resizer\";\nimport { isRTLDocument } from \"../core/environment\";\n\n/**\n * @internal\n */\nexport const ListItem = /*#__PURE__*/ defineComponent({\n  props: {\n    _children: { type: Object as PropType<VNode>, required: true },\n    _resizer: {\n      type: Function as PropType<ItemResizeObserver>,\n      required: true,\n    },\n    _index: { type: Number, required: true },\n    _offset: { type: Number, required: true },\n    _hide: { type: Boolean },\n    _isHorizontal: { type: Boolean },\n    _isSSR: { type: Boolean },\n    _as: { type: String as PropType<keyof NativeElements>, required: true },\n  },\n  setup(props) {\n    const elementRef = ref<HTMLDivElement>();\n\n    // The index may be changed if elements are inserted to or removed from the start of props.children\n    watch(\n      () => elementRef.value && props._index,\n      (_, __, onCleanup) => {\n        onCleanup(props._resizer(elementRef.value!, props._index));\n      },\n      {\n        flush: \"post\",\n      }\n    );\n\n    return () => {\n      const {\n        _children: children,\n        _offset: offset,\n        _hide: hide,\n        _isHorizontal: isHorizontal,\n        _isSSR: isSSR,\n        _as: Element,\n      } = props;\n\n      const style: StyleValue = {\n        margin: 0,\n        padding: 0,\n        position: hide && isSSR ? undefined : \"absolute\",\n        [isHorizontal ? \"height\" : \"width\"]: \"100%\",\n        [isHorizontal ? \"top\" : \"left\"]: \"0px\",\n        [isHorizontal ? (isRTLDocument() ? \"right\" : \"left\") : \"top\"]:\n          offset + \"px\",\n        visibility: !hide || isSSR ? \"visible\" : \"hidden\",\n      };\n      if (isHorizontal) {\n        style.display = \"flex\";\n      }\n\n      return (\n        <Element ref={elementRef} style={style}>\n          {children}\n        </Element>\n      );\n    };\n  },\n});\n","import { VNode } from \"vue\";\nimport { NULL } from \"../core/utils\";\n\n/**\n * @internal\n */\nexport const getKey = (e: VNode, i: number): Exclude<VNode[\"key\"], null> => {\n  const key = e.key;\n  return key != NULL ? key : \"_\" + i;\n};\n","/** @jsxImportSource vue */\nimport {\n  ref,\n  onMounted,\n  defineComponent,\n  onUnmounted,\n  VNode,\n  watch,\n  ComponentOptionsMixin,\n  SlotsType,\n  ComponentOptionsWithObjectProps,\n  ComponentObjectPropsOptions,\n  PropType,\n  NativeElements,\n} from \"vue\";\nimport {\n  SCROLL_IDLE,\n  UPDATE_SCROLL_EVENT,\n  UPDATE_SCROLL_END_EVENT,\n  UPDATE_VIRTUAL_STATE,\n  getOverscanedRange,\n  createVirtualStore,\n  ACTION_ITEMS_LENGTH_CHANGE,\n  getScrollSize,\n  ACTION_START_OFFSET_CHANGE,\n} from \"../core/store\";\nimport { createResizer } from \"../core/resizer\";\nimport { createScroller } from \"../core/scroller\";\nimport { ScrollToIndexOpts } from \"../core/types\";\nimport { ListItem } from \"./ListItem\";\nimport { getKey } from \"./utils\";\nimport { microtask } from \"../core/utils\";\n\nexport interface VirtualizerHandle {\n  /**\n   * Get current scrollTop or scrollLeft.\n   */\n  readonly scrollOffset: number;\n  /**\n   * Get current scrollHeight or scrollWidth.\n   */\n  readonly scrollSize: number;\n  /**\n   * Get current offsetHeight or offsetWidth.\n   */\n  readonly viewportSize: number;\n  /**\n   * Get item offset from start.\n   * @param index index of item\n   */\n  getItemOffset(index: number): number;\n  /**\n   * Scroll to the item specified by index.\n   * @param index index of item\n   * @param opts options\n   */\n  scrollToIndex(index: number, opts?: ScrollToIndexOpts): void;\n  /**\n   * Scroll to the given offset.\n   * @param offset offset from start\n   */\n  scrollTo(offset: number): void;\n  /**\n   * Scroll by the given offset.\n   * @param offset offset from current position\n   */\n  scrollBy(offset: number): void;\n}\n\nconst props = {\n  /**\n   * The data items rendered by this component.\n   */\n  data: { type: Array, required: true },\n  /**\n   * Number of items to render above/below the visible bounds of the list. You can increase to avoid showing blank items in fast scrolling.\n   * @defaultValue 4\n   */\n  overscan: { type: Number, default: 4 },\n  /**\n   * Item size hint for unmeasured items. It will help to reduce scroll jump when items are measured if used properly.\n   *\n   * - If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.\n   * - If set, you can opt out estimation and use the value as initial item size.\n   */\n  itemSize: Number,\n  /**\n   * While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.\n   */\n  shift: Boolean,\n  /**\n   * If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.\n   */\n  horizontal: Boolean,\n  /**\n   * If you put an element before virtualizer, you have to define its height with this prop.\n   */\n  startMargin: { type: Number, default: 0 },\n  /**\n   * A prop for SSR. If set, the specified amount of items will be mounted in the initial rendering regardless of the container size until hydrated.\n   */\n  ssrCount: Number,\n  /**\n   * Reference to the scrollable element. The default will get the parent element of virtualizer.\n   */\n  scrollRef: Object as PropType<HTMLElement>,\n  /**\n   * Component or element type for container element.\n   * @defaultValue \"div\"\n   */\n  as: { type: String as PropType<keyof NativeElements>, default: \"div\" },\n  /**\n   * Component or element type for item element.\n   * @defaultValue \"div\"\n   */\n  item: { type: String as PropType<keyof NativeElements>, default: \"div\" },\n} satisfies ComponentObjectPropsOptions;\n\nexport const Virtualizer = /*#__PURE__*/ defineComponent({\n  props: props,\n  emits: [\"scroll\", \"scrollEnd\", \"rangeChange\"],\n  setup(props, { emit, expose, slots }) {\n    let isSSR = !!props.ssrCount;\n\n    const isHorizontal = props.horizontal;\n    const containerRef = ref<HTMLDivElement>();\n    const store = createVirtualStore(\n      props.data.length,\n      props.itemSize ?? 40,\n      props.ssrCount,\n      undefined,\n      !props.itemSize\n    );\n    const resizer = createResizer(store, isHorizontal);\n    const scroller = createScroller(store, isHorizontal);\n\n    const rerender = ref(store._getStateVersion());\n    const unsubscribeStore = store._subscribe(UPDATE_VIRTUAL_STATE, () => {\n      rerender.value = store._getStateVersion();\n    });\n\n    const unsubscribeOnScroll = store._subscribe(UPDATE_SCROLL_EVENT, () => {\n      emit(\"scroll\", store._getScrollOffset());\n    });\n    const unsubscribeOnScrollEnd = store._subscribe(\n      UPDATE_SCROLL_END_EVENT,\n      () => {\n        emit(\"scrollEnd\");\n      }\n    );\n\n    onMounted(() => {\n      isSSR = false;\n\n      microtask(() => {\n        const assignScrollableElement = (e: HTMLElement) => {\n          resizer._observeRoot(e);\n          scroller._observe(e);\n        };\n        if (props.scrollRef) {\n          // parent's ref doesn't exist when onMounted is called\n          assignScrollableElement(props.scrollRef!);\n        } else {\n          assignScrollableElement(containerRef.value!.parentElement!);\n        }\n      });\n    });\n    onUnmounted(() => {\n      unsubscribeStore();\n      unsubscribeOnScroll();\n      unsubscribeOnScrollEnd();\n      resizer._dispose();\n      scroller._dispose();\n    });\n\n    watch(\n      () => props.data.length,\n      (count) => {\n        store._update(ACTION_ITEMS_LENGTH_CHANGE, [count, props.shift]);\n      }\n    );\n    watch(\n      () => props.startMargin,\n      (value) => {\n        store._update(ACTION_START_OFFSET_CHANGE, value);\n      },\n      { immediate: true }\n    );\n\n    watch(\n      [rerender, store._getJumpCount],\n      ([, count], [, prevCount]) => {\n        if (count === prevCount) return;\n\n        scroller._fixScrollJump();\n      },\n      { flush: \"post\" }\n    );\n\n    watch(\n      [rerender, store._getRange],\n      ([, [start, end]], [, [prevStart, prevEnd]]) => {\n        if (prevStart === start && prevEnd === end) return;\n\n        emit(\"rangeChange\", start, end);\n      },\n      { flush: \"post\" }\n    );\n\n    expose({\n      get scrollOffset() {\n        return store._getScrollOffset();\n      },\n      get scrollSize() {\n        return getScrollSize(store);\n      },\n      get viewportSize() {\n        return store._getViewportSize();\n      },\n      getItemOffset: store._getItemOffset,\n      scrollToIndex: scroller._scrollToIndex,\n      scrollTo: scroller._scrollTo,\n      scrollBy: scroller._scrollBy,\n    } satisfies VirtualizerHandle);\n\n    return () => {\n      rerender.value;\n\n      const Element = props.as;\n      const ItemElement = props.item;\n      const count = props.data.length;\n\n      const [startIndex, endIndex] = store._getRange();\n      const scrollDirection = store._getScrollDirection();\n      const totalSize = store._getTotalSize();\n\n      const items: VNode[] = [];\n      for (\n        let [i, j] = getOverscanedRange(\n          startIndex,\n          endIndex,\n          props.overscan,\n          scrollDirection,\n          count\n        );\n        i <= j;\n        i++\n      ) {\n        const e = slots.default(props.data![i]!)[0]! as VNode;\n        items.push(\n          <ListItem\n            key={getKey(e, i)}\n            _resizer={resizer._observeItem}\n            _index={i}\n            _offset={store._getItemOffset(i)}\n            _hide={store._isUnmeasuredItem(i)}\n            _children={e}\n            _isHorizontal={isHorizontal}\n            _isSSR={isSSR}\n            _as={ItemElement}\n          />\n        );\n      }\n\n      return (\n        <Element\n          ref={containerRef}\n          style={{\n            // contain: \"content\",\n            overflowAnchor: \"none\", // opt out browser's scroll anchoring because it will conflict to scroll anchoring of virtualizer\n            flex: \"none\", // flex style can break layout\n            position: \"relative\",\n            visibility: \"hidden\", // TODO replace with other optimization methods\n            width: isHorizontal ? totalSize + \"px\" : \"100%\",\n            height: isHorizontal ? \"100%\" : totalSize + \"px\",\n            pointerEvents: scrollDirection !== SCROLL_IDLE ? \"none\" : \"auto\",\n          }}\n        >\n          {items}\n        </Element>\n      );\n    };\n  },\n} as ComponentOptionsWithObjectProps<\n  typeof props,\n  VirtualizerHandle,\n  {},\n  {},\n  {},\n  ComponentOptionsMixin,\n  ComponentOptionsMixin,\n  {\n    /**\n     * Callback invoked whenever scroll offset changes.\n     * @param offset Current scrollTop or scrollLeft.\n     */\n    scroll: (offset: number) => void;\n    /**\n     * Callback invoked when scrolling stops.\n     */\n    scrollEnd: () => void;\n    /**\n     * Callback invoked when visible items range changes.\n     */\n    rangeChange: (\n      /**\n       * The start index of viewable items.\n       */\n      startIndex: number,\n      /**\n       * The end index of viewable items.\n       */\n      endIndex: number\n    ) => void;\n  },\n  string,\n  {},\n  string,\n  SlotsType<{ default: any }>\n>);\n","/** @jsxImportSource vue */\nimport {\n  defineComponent,\n  ComponentOptionsMixin,\n  SlotsType,\n  ComponentOptionsWithObjectProps,\n  ComponentObjectPropsOptions,\n  ref,\n} from \"vue\";\nimport { Virtualizer, VirtualizerHandle } from \"./Virtualizer\";\n\ninterface VListHandle extends VirtualizerHandle {}\n\nconst props = {\n  /**\n   * The data items rendered by this component.\n   */\n  data: { type: Array, required: true },\n  /**\n   * Number of items to render above/below the visible bounds of the list. You can increase to avoid showing blank items in fast scrolling.\n   * @defaultValue 4\n   */\n  overscan: { type: Number, default: 4 },\n  /**\n   * Item size hint for unmeasured items. It will help to reduce scroll jump when items are measured if used properly.\n   *\n   * - If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.\n   * - If set, you can opt out estimation and use the value as initial item size.\n   */\n  itemSize: Number,\n  /**\n   * While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.\n   */\n  shift: Boolean,\n  /**\n   * If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.\n   */\n  horizontal: Boolean,\n  /**\n   * A prop for SSR. If set, the specified amount of items will be mounted in the initial rendering regardless of the container size until hydrated.\n   */\n  ssrCount: Number,\n} satisfies ComponentObjectPropsOptions;\n\nexport const VList = /*#__PURE__*/ defineComponent({\n  props: props,\n  emits: [\"scroll\", \"scrollEnd\", \"rangeChange\"],\n  setup(props, { emit, expose, slots }) {\n    const horizontal = props.horizontal;\n\n    const onScroll = (offset: number) => {\n      emit(\"scroll\", offset);\n    };\n    const onScrollEnd = () => {\n      emit(\"scrollEnd\");\n    };\n    const onRangeChange = (start: number, end: number) => {\n      emit(\"rangeChange\", start, end);\n    };\n\n    const handle = ref<InstanceType<typeof Virtualizer>>();\n\n    expose({\n      get scrollOffset() {\n        return handle.value!.scrollOffset;\n      },\n      get scrollSize() {\n        return handle.value!.scrollSize;\n      },\n      get viewportSize() {\n        return handle.value!.viewportSize;\n      },\n      getItemOffset: (...args) => handle.value!.getItemOffset(...args),\n      scrollToIndex: (...args) => handle.value!.scrollToIndex(...args),\n      scrollTo: (...args) => handle.value!.scrollTo(...args),\n      scrollBy: (...args) => handle.value!.scrollBy(...args),\n    } satisfies VListHandle);\n\n    return () => {\n      return (\n        <div\n          style={{\n            display: horizontal ? \"inline-block\" : \"block\",\n            [horizontal ? \"overflowX\" : \"overflowY\"]: \"auto\",\n            contain: \"strict\",\n            width: \"100%\",\n            height: \"100%\",\n          }}\n        >\n          <Virtualizer\n            ref={handle}\n            data={props.data}\n            overscan={props.overscan}\n            itemSize={props.itemSize}\n            shift={props.shift}\n            ssrCount={props.ssrCount}\n            horizontal={horizontal}\n            onScroll={onScroll}\n            onScrollEnd={onScrollEnd}\n            onRangeChange={onRangeChange}\n          >\n            {slots}\n          </Virtualizer>\n        </div>\n      );\n    };\n  },\n} as ComponentOptionsWithObjectProps<\n  typeof props,\n  VListHandle,\n  {},\n  {},\n  {},\n  ComponentOptionsMixin,\n  ComponentOptionsMixin,\n  {\n    /**\n     * Callback invoked whenever scroll offset changes.\n     * @param offset Current scrollTop or scrollLeft.\n     */\n    scroll: (offset: number) => void;\n    /**\n     * Callback invoked when scrolling stops.\n     */\n    scrollEnd: () => void;\n    /**\n     * Callback invoked when visible items range changes.\n     */\n    rangeChange: (\n      /**\n       * The start index of viewable items.\n       */\n      startIndex: number,\n      /**\n       * The end index of viewable items.\n       */\n      endIndex: number\n    ) => void;\n  },\n  string,\n  {},\n  string,\n  SlotsType<{ default: any }>\n>);\n","/** @jsxImportSource vue */\nimport {\n  ref,\n  onMounted,\n  defineComponent,\n  onUnmounted,\n  VNode,\n  watch,\n  ComponentOptionsMixin,\n  SlotsType,\n  ComponentOptionsWithObjectProps,\n  ComponentObjectPropsOptions,\n  PropType,\n  NativeElements,\n} from \"vue\";\nimport {\n  SCROLL_IDLE,\n  UPDATE_SCROLL_END_EVENT,\n  UPDATE_VIRTUAL_STATE,\n  getOverscanedRange,\n  createVirtualStore,\n  ACTION_ITEMS_LENGTH_CHANGE,\n} from \"../core/store\";\nimport { createWindowResizer } from \"../core/resizer\";\nimport { createWindowScroller } from \"../core/scroller\";\nimport { ListItem } from \"./ListItem\";\nimport { getKey } from \"./utils\";\n\nconst props = {\n  /**\n   * The data items rendered by this component.\n   */\n  data: { type: Array, required: true },\n  /**\n   * Number of items to render above/below the visible bounds of the list. You can increase to avoid showing blank items in fast scrolling.\n   * @defaultValue 4\n   */\n  overscan: { type: Number, default: 4 },\n  /**\n   * Item size hint for unmeasured items. It will help to reduce scroll jump when items are measured if used properly.\n   *\n   * - If not set, initial item sizes will be automatically estimated from measured sizes. This is recommended for most cases.\n   * - If set, you can opt out estimation and use the value as initial item size.\n   */\n  itemSize: Number,\n  /**\n   * While true is set, scroll position will be maintained from the end not usual start when items are added to/removed from start. It's recommended to set false if you add to/remove from mid/end of the list because it can cause unexpected behavior. This prop is useful for reverse infinite scrolling.\n   */\n  shift: Boolean,\n  /**\n   * If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.\n   */\n  horizontal: Boolean,\n  /**\n   * Component or element type for container element.\n   * @defaultValue \"div\"\n   */\n  as: { type: String as PropType<keyof NativeElements>, default: \"div\" },\n  /**\n   * Component or element type for item element.\n   * @defaultValue \"div\"\n   */\n  item: { type: String as PropType<keyof NativeElements>, default: \"div\" },\n} satisfies ComponentObjectPropsOptions;\n\nexport const WindowVirtualizer = /*#__PURE__*/ defineComponent({\n  props,\n  emits: [\"scrollEnd\", \"rangeChange\"],\n  setup(props, { emit, slots }) {\n    const isHorizontal = props.horizontal;\n    const containerRef = ref<HTMLDivElement>();\n    const store = createVirtualStore(\n      props.data.length,\n      props.itemSize ?? 40,\n      undefined,\n      undefined,\n      !props.itemSize\n    );\n    const resizer = createWindowResizer(store, isHorizontal);\n    const scroller = createWindowScroller(store, isHorizontal);\n\n    const rerender = ref(store._getStateVersion());\n    const unsubscribeStore = store._subscribe(UPDATE_VIRTUAL_STATE, () => {\n      rerender.value = store._getStateVersion();\n    });\n\n    const unsubscribeOnScrollEnd = store._subscribe(\n      UPDATE_SCROLL_END_EVENT,\n      () => {\n        emit(\"scrollEnd\");\n      }\n    );\n\n    onMounted(() => {\n      const el = containerRef.value;\n      if (!el) return;\n      resizer._observeRoot(el);\n      scroller._observe(el);\n    });\n    onUnmounted(() => {\n      unsubscribeStore();\n      unsubscribeOnScrollEnd();\n      resizer._dispose();\n      scroller._dispose();\n    });\n\n    watch(\n      () => props.data.length,\n      (count) => {\n        store._update(ACTION_ITEMS_LENGTH_CHANGE, [count, props.shift]);\n      }\n    );\n\n    watch(\n      [rerender, store._getJumpCount],\n      ([, count], [, prevCount]) => {\n        if (count === prevCount) return;\n\n        scroller._fixScrollJump();\n      },\n      { flush: \"post\" }\n    );\n\n    watch(\n      [rerender, store._getRange],\n      ([, [start, end]], [, [prevStart, prevEnd]]) => {\n        if (prevStart === start && prevEnd === end) return;\n\n        emit(\"rangeChange\", start, end);\n      },\n      { flush: \"post\" }\n    );\n\n    return () => {\n      rerender.value;\n    \n      const Element = props.as;\n      const ItemElement = props.item;\n      const count = props.data.length;\n\n      const [startIndex, endIndex] = store._getRange();\n      const scrollDirection = store._getScrollDirection();\n      const totalSize = store._getTotalSize();\n\n      const items: VNode[] = [];\n      for (\n        let [i, j] = getOverscanedRange(\n          startIndex,\n          endIndex,\n          props.overscan,\n          scrollDirection,\n          count\n        );\n        i <= j;\n        i++\n      ) {\n        const e = slots.default(props.data![i]!)[0]! as VNode;\n        items.push(\n          <ListItem\n            key={getKey(e, i)}\n            _resizer={resizer._observeItem}\n            _index={i}\n            _offset={store._getItemOffset(i)}\n            _hide={store._isUnmeasuredItem(i)}\n            _children={e}\n            _isHorizontal={isHorizontal}\n            _as={ItemElement}\n          />\n        );\n      }\n\n      return (\n        <Element\n          ref={containerRef}\n          style={{\n            // contain: \"content\",\n            overflowAnchor: \"none\", // opt out browser's scroll anchoring because it will conflict to scroll anchoring of virtualizer\n            flex: \"none\", // flex style can break layout\n            position: \"relative\",\n            visibility: \"hidden\", // TODO replace with other optimization methods\n            width: isHorizontal ? totalSize + \"px\" : \"100%\",\n            height: isHorizontal ? \"100%\" : totalSize + \"px\",\n            pointerEvents: scrollDirection !== SCROLL_IDLE ? \"none\" : \"auto\",\n          }}\n        >\n          {items}\n        </Element>\n      );\n    };\n  },\n} as ComponentOptionsWithObjectProps<\n  typeof props,\n  void,\n  {},\n  {},\n  {},\n  ComponentOptionsMixin,\n  ComponentOptionsMixin,\n  {\n    /**\n     * Callback invoked when scrolling stops.\n     */\n    scrollEnd: () => void;\n    /**\n     * Callback invoked when visible items range changes.\n     */\n    rangeChange: (\n      /**\n       * The start index of viewable items.\n       */\n      startIndex: number,\n      /**\n       * The end index of viewable items.\n       */\n      endIndex: number\n    ) => void;\n  },\n  string,\n  {},\n  string,\n  SlotsType<{ default: any }>\n>);\n"],"names":["NULL","min","Math","max","abs","timeout","setTimeout","clamp","value","minValue","maxValue","microtask","queueMicrotask","fn","Promise","resolve","then","once","called","cache","args","UNCACHED","fill","array","length","prepend","key","i","getItemSize","index","size","_sizes","_defaultItemSize","setItemSize","isInitialMeasurement","_computedOffsetIndex","computeOffset","_length","_offsets","top","findIndex","offset","itemOffset","updateCacheLength","isShift","diff","splice","reduce","acc","removed","isBrowser","window","getDocumentElement","document","documentElement","getCurrentDocument","node","ownerDocument","getCurrentWindow","doc","defaultView","isRTLDocument","getComputedStyle","direction","isIOSWebKit","test","navigator","userAgent","isSmoothScrollSupported","style","getOverscanedRange","startIndex","endIndex","overscan","scrollDirection","count","createVirtualStore","elementsCount","itemSize","ssrCount","cacheSnapshot","shouldAutoEstimateItemSize","isSSR","stateVersion","viewportSize","startSpacerSize","scrollOffset","jumpCount","jump","pendingJump","_flushedJump","_scrollDirection","_scrollMode","_frozenRange","_prevRange","_totalMeasuredSize","initCache","subscribers","Set","getRelativeScrollOffset","getRange","computeRange","prevStartIndex","start","getTotalSize","computeTotalSize","getItemOffset","computeStartOffset","_getItemSize","applyJump","j","_getStateVersion","_getCacheSnapshot","takeCacheSnapshot","_getRange","_isUnmeasuredItem","_isInitialMeasurementDone","_hasUnmeasuredItemsInFrozenRange","slice","includes","_getItemOffset","_getItemsLength","_getScrollOffset","_getScrollDirection","_getViewportSize","_getStartSpacerSize","_getTotalSize","_getJumpCount","_flushJump","_subscribe","target","cb","sub","add","delete","_update","type","payload","shouldFlushPendingJump","shouldSync","mutated","flushedJump","delta","distance","relativeOffset","updated","filter","prevSize","estimateDefaultItemSize","measuredCountBeforeStart","measuredSizes","s","isMeasured","prevDefaultItemSize","arr","sorted","sort","a","b","mid","median","UPDATE_VIRTUAL_STATE","forEach","createResizeObserver","ro","_observe","e","observe","_unobserve","unobserve","_dispose","disconnect","normalizeOffset","isHorizontal","createScrollObserver","store","viewport","getScrollOffset","updateScrollOffset","getStartOffset","now","Date","lastScrollTime","wheeling","touching","justTouchEnded","stillMomentumScrolling","onScrollEnd","debounce","id","cancel","clearTimeout","debouncedFn","_cancel","onScroll","onWheel","ctrlKey","timeDelta","deltaX","deltaY","onTouchStart","onTouchEnd","addEventListener","passive","removeEventListener","_fixScrollJump","shift","ListItem","defineComponent","props","_children","Object","required","_resizer","Function","_index","Number","_offset","_hide","Boolean","_isHorizontal","_isSSR","_as","String","setup","elementRef","ref","watch","_","__","onCleanup","flush","children","hide","Element","margin","padding","position","undefined","visibility","display","_createVNode","_isVNode","prototype","toString","call","isVNode","default","getKey","data","Array","horizontal","startMargin","scrollRef","as","item","Virtualizer","emits","emit","expose","slots","containerRef","_a","resizer","createResizer","viewportElement","sizeKey","mountedIndexes","WeakMap","resizeObserver","entries","resizes","contentRect","offsetParent","get","push","_observeRoot","_observeItem","el","set","scroller","createScroller","scrollObserver","cancelScroll","scrollOffsetKey","overflowKey","scheduleImperativeScroll","async","getTargetOffset","smooth","waitForMeasurement","queue","reject","promise","unsubscribe","scrollTo","behavior","isMomentumScrolling","prev","_scrollTo","_scrollBy","_scrollToIndex","align","rerender","unsubscribeStore","unsubscribeOnScroll","unsubscribeOnScrollEnd","onMounted","assignScrollableElement","parentElement","onUnmounted","immediate","prevCount","end","prevStart","prevEnd","scrollSize","getScrollSize","scrollToIndex","scrollBy","ItemElement","totalSize","items","createVNode","Y","F","U","V","X","G","K","Z","overflowAnchor","flex","width","height","pointerEvents","VList","onRangeChange","handle","contain","WindowVirtualizer","createWindowResizer","windowSizeKey","cleanupOnWindowResize","container","onWindowResize","createWindowScroller","documentBody","body","calcOffsetToViewport","offsetKey","offsetSum","innerWidth","offsetWidth","parent","scroll","opts","targetOffset","finalOffset","requestAnimationFrame"],"mappings":"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"}